---

layout:     post
title:      "java的学习笔记1·面向对象"
subtitle:   ""
date:       2018-12-02 22:11:00
author:     "whale"
header-img: "img/photo-java.jpg"
header-mask: 0.3
catalog:    true
tags:

- java

---



## 成员变量与局部变量的区别

##### 1.生命周期

成员变量属于对象，跟随对象进入堆内存，生命周期为对象的生命周期。

局部变量属于函数的临时变量，只跟随函数调用进入栈中，随着函数的销毁而销毁，即生命周期为函数的长短。

##### 2.初始值不同

成员变量：有默认初始值

局部变量：没有默认值，必须赋值后才能使用

ps：局部变量可以与函数的局部变量名相同，因为一个在堆内存一个在栈空间。



## 匿名对象

##### 概念

如果有一个类car()

car c =new car() ; c.run()为有名对象的函数调用

new car().run(); 为**匿名对象**的函数调用

匿名对象一旦创建只会被运行一次，不会返回在堆内存中的地址值，成为垃圾，被垃圾回收算法回收。

##### 应用场景

可以为函数传参，因为这样匿名对象的生命周期与函数一致。使代码简洁。



## 封装

##### 概念

对外屏蔽类的内部的私有函数和私有成员，而公开一些对外的函数，以供外部的调用这些接口而无需关心内部的结构。

##### 好处

安全，代码复用

##### private关键字修饰

可以用private关键字来修饰函数和成员变量，并且提供public函数setXXX()和getXXX()函数来让外界可以获取被私有成员与函数。

##### this关键字修饰

表示当前对象的引用，用来区分重名的局部变量和成员变量

## static 关键字

- 被static修饰的成员一般储存在类的代码中（储存在类的静态区域），而类是被所有的对象所共享的 ，所以static成员也被所有对象共享
- 推荐通过类名调用，（也可以用对象来调用）
- 类优先于对象而存在，所以静态成员不能访问非静态成员（因为非静态成员依靠对象存在而存在，已存在的东西不能访问未知的东西），所以静态成员只能相互访问

#### 成员变量与静态成员的区别

1. 所属不同：

   静态成员属于类，成员变量属于对象

2. 内存位置不同：

   静态变量储存在方法区的静态区，成员变量储存在堆内存中

3. 生命周期不同

   静态变量随着类的加载而加载，消失而消失

   成员变量随着对象的创建而存在，销毁而销毁

4. 调用不同

   静态变量用 类名.静态变量 来调用

   成员变量用 对象名.成员变量 来调用

## extends关键字-类的继承

好处 ：

- 提高了代码的复用性
- 提高了代码的可维护性
- 让类之间产生了关系，多态的前提

弊端：

- 增加了类之间的耦合性

（开发的原则是高内聚低耦合）

### java的继承特点

- java只支持***单继承***，支持**继承家族**（继承体系）

### java继承的注意事项

1. 子类只能继承父类的非私有成员
2. 子类不能继承父类非super关键字修饰的构造方法
3. 子类不能重写父类的私有函数
4. 子类重写父类的方法时，权限不能更低

## super关键字

this代表当前对象的引用，super代表当前对象的父类的引用

两者的使用区别：

- 调用成员变量或方法 -》this.menber/this.fun() this既可以调用对象也可以调用父类中的成员或者方法；super.member/super.fun() super只能调用父类的成员

- 调用构造方法：子类的每一个构造方法都会自动调用super()语句（系统自动加），这个语句用来访问父类的空参构造方法。

   即每个子类的构造函数都会先进行父类的数据初始化再进行自己的数据的初始化。

  （object类是所有类的最顶层类）

###### 注意：当父类只有有参构造时，子类的有参构造方法应主动写super（...）语句，并传入构造函数的参数、例如

```java
class demo{

public demo(int a,string b){

super(a,b);

}

}
```

## final关键字

- 修饰类，类不能被继承
- 修饰变量，变量就变成了常量，只能被赋值一次
- 修饰方法，方法不能被重写

### 方法重写与方法重载的区别

- overload可以改变返回值类型,只看参数列表
- 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的
- 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。
- 子类对象调用方法的时候：
  - 先找子类本身，再找父类。

## 常见代码块的应用

- a:局部代码块 
  - 在方法中出现；限定变量生命周期，及早释放，提高内存利用率
- b:构造代码块 (初始化块)
  - 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
- c:静态代码块 
  - 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。
  - 一般用于加载驱动

## java的文档注释

java有三种注释方式，第三种是文档注释，语法如下

```
/**

*类或者方法的描述

@version v1.9版本

@author  作者

@return 返回值的描述

@param 参数 参数的描述

....

*/
```

用javadoc工具来生成html说明文档，命令行如下

```
javadoc -d path file.java
```

样例如下

```c
/**
  这是测试注释文档的demo
  @author me
  @version v1.0
 */
public class demo
{
	/**
	 * 这是私有的构造函数，不会在注释文档中出现
	  @return null
	 */
	private demo(){}
	/**
	 * 用来测试的第一个函数
	 * @param  i 一个整型数据
	 * @return  i本身
	 */
	public static int test1(int i)
	{
		return i;
	}
	/**
	 * 用来测试的第二个文档
	 * @param  j 一个整型数据
	 * @return   返回j的平方
	 */
	public static int test2(int j)
	{
		return j*j;
	}
}
```

cmd输出如下

```bash
C:\Users\Administrator\Desktop\tset>javadoc -d api -version -author demo.java
正在加载源文件demo.java...
正在构造 Javadoc 信息...
正在创建目标目录: "api\"
标准 Doclet 版本 1.8.0_191
正在构建所有程序包和类的树...
正在生成api\demo.html...
正在生成api\package-frame.html...
正在生成api\package-summary.html...
正在生成api\package-tree.html...
正在生成api\constant-values.html...
正在构建所有程序包和类的索引...
正在生成api\overview-tree.html...
正在生成api\index-all.html...
正在生成api\deprecated-list.html...
正在构建所有类的索引...
正在生成api\allclasses-frame.html...
正在生成api\allclasses-noframe.html...
正在生成api\index.html...
正在生成api\help-doc.html...
```